$PSScriptRoot = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition

Get-ChildItem $PSScriptRoot\subModules\*.psm1 | Foreach-Object {
    Import-Module $_.FullName -Force
}

function New-Menu
{
    Param(
        [Parameter(Mandatory=$true)]$InputObject, # Could be a DirectoryInfo or something else
        [Parameter(Mandatory=$false)][String]$DisplayProperty,  # The name of the property of items to be 
                                                                # displayed on the menu, such as Name
        [int]$X = 0,
        [int]$Y = $Host.UI.RawUI.WindowPosition.Y,
        [Int]$Width = 12,
        [Int]$Height = 6,
        [Switch]$NoAutoSize,
        [Char]$Character = ' ',
        [String]$ForegroundColor,
        [String]$BackgroundColor,
        [String]$ItemHighlightColor = 'Green',
        [String]$ParentID,
        [Int]$EdgeWidth = 2,
        [Int]$EdgeHeight = 1
    )

    # These can't seem to be defined directly as the default values in the parameters
    if (-not $ForegroundColor) { $ForegroundColor = $Host.UI.RawUI.BackgroundColor }
    if (-not $BackgroundColor) { $BackgroundColor = $Host.UI.RawUI.ForegroundColor }

    # TODO The buffer should probably be stored right before writing the menu instad of when the menu is initialized
    # TODO Add different options (a switch or something) for automatic positioning the menu
    # TODO Handle lists higher than the window, for example:
    #
    #   +
    # ITEM 3
    # ITEM 4
    # ITEM 5 
    #   +
    #
    # TODO Maybe add the ability to input a fairly arbitrary single object, like something from WMI
    # TODO A Property parameter that allows you to pick the property the value of which
    # will be picked from to display
    # TODO Begin with moving the cursor to the bottom left of the window so the script doesn't break 
    # if it's positioned too high or in other unexpected places

    # Create a mapping object for attaching an item index number to a line number on the buffer
    $script:lineMap = @() # TODO Move this to be beginning of the function

    $firstMenuItemLineNumber = 0 # Line on which to write the first displayed item
     $lastMenuItemLineNumber = 0 # Line on which to write the last displayed item
    $firstDisplayedItemIndex = 0 # Index number of the first item getting displayed
     $lastDisplayedItemIndex = 0 # Index number of the last item getting displayed

    if ($InputObject -is [System.IO.DirectoryInfo]) {
        $menu = [PSCustomObject]@{
            ParentID = $ParentID
            Content = New-DirectoryMenuContent -Directory $InputObject
            ItemHighlightColor = $ItemHighlightColor
            EdgeWidth = $EdgeWidth
            EdgeHeight = $EdgeHeight
        }
        $menu | Add-Member -MemberType NoteProperty -Name ID -Value $menu.Content.FullName
    } elseif ($InputObject -is [Array]) {
        $menu = [PSCustomObject]@{
            ParentID = $ParentID
            Content =   if (-not $DisplayProperty) {
                            New-ArrayMenuContent -Array $InputObject
                        } else {
                            New-ArrayMenuContent -Array $InputObject -DisplayProperty $DisplayProperty
                        }
            ItemHighlightColor = $ItemHighlightColor
            EdgeWidth = $EdgeWidth
            EdgeHeight = $EdgeHeight
        }
        $menu | Add-Member -MemberType NoteProperty -Name ID -Value (Get-Random)
    } else {
        throw 'Unsupported InputObject type.'
    }

    $menu | Add-Member -MemberType NoteProperty -Name Square -Value (
        New-Square -X $X -Y $Y -Width $Width -Height $Height -Character $Character `
            -ForegroundColor $ForegroundColor -BackgroundColor $BackgroundColor
    )

    $menu | Add-Member -MemberType ScriptMethod -Name SetSquareWidthToItemWidth -Value `
    {
        $this.Square.SetWidth($this.Content.ItemMaxLen)
    }
    $menu | Add-Member -MemberType ScriptMethod -Name SetSquareHeightToItemHeight -Value `
    {
        if ($this.Content.Items.Count + $EdgeHeight * 2 -gt $Host.UI.RawUI.WindowSize.Height) {
            # The square will not fit in the window, make it the same height as the window
            $this.Square.SetHeight($Host.UI.RawUI.WindowSize.Height - $EdgeHeight * 2)
        } else {
            $this.Square.SetHeight($this.Content.Items.Count)
        }
    }
    $menu | Add-Member -MemberType ScriptMethod -Name SetSquareToItemSize -Value `
    {
        $this.SetSquareWidthToItemWidth()
        $this.SetSquareHeightToItemHeight()
    }

    # Automatically size the menu to fit items on it
    if ((-not $NoAutoSize.IsPresent) -and ($menu.Content.Items)) {
        $menu.SetSquareToItemSize()
    }

    $menu.Square.GrowWidth($menu.EdgeWidth * 2)
    $menu.Square.GrowHeight($menu.EdgeHeight * 2)
     
    # Move the menu horizontally to the middle of the window
    $menu.Square.SetPosition(
        ([Math]::Floor($Host.UI.RawUI.WindowSize.Width / 2) - $menu.Square.Width),
        ($menu.Square.Position.Y)
    )
    # Move the menu vertically to the middle of the window
    $menu.Square.SetPosition(
        ($menu.Square.Position.X),
        (
            ($menu.Square.Position.Y + [Math]::Floor($Host.UI.RawUI.WindowSize.Height / 2)) - `
            [Math]::Floor($menu.Square.Height / 2)
        )
    )

    # Set which line to write the first item to the beginning of the menu
    $firstMenuItemLineNumber = $menu.Square.Position.Y + $menu.EdgeHeight
    
    # Set which line to write the last item to the end of the menu
    $lastMenuItemLineNumber = $menu.Square.Position.Y + $menu.Square.Height - ($menu.EdgeHeight * 2)

    # Set the index of the last item to write to correspond to the height of the menu
    $lastDisplayedItemIndex = $firstDisplayedItemIndex + $menu.Square.Height - ($menu.EdgeHeight * 2)

    # At this point we can simply start picking the indeces from 0, incrementing by 1 on each line
    $i = 0
    foreach ($lineNumber in $firstMenuItemLineNumber..$lastMenuItemLineNumber) {
        $script:lineMap += [PSCustomObject]@{
            Number    = $lineNumber
            ItemIndex = $i
        }
        $i++
    }

    $menu | Add-Member -MemberType ScriptMethod -Name WriteItem -Value `
    {
        Param(
            [Int]$ItemIndex = $this.Content.CurrentItem,
            [String]$ForegroundColor = $this.Square.ForegroundColor,
            [Int]$LineNumber = 0
        )

        $pos   = $Host.UI.RawUI.WindowPosition
        $pos.X = $this.Square.Position.X + $this.EdgeWidth
        $pos.Y = $LineNumber

        $itemName = $this.Content.GetItemName($ItemIndex)
        $fgColor  = $ForegroundColor
        $bgColor  = $this.Square.BackgroundColor

        $outBuffer = $Host.UI.RawUI.NewBufferCellArray($itemName,$fgColor,$bgColor)
        $Host.UI.RawUI.SetBufferContents($pos,$outBuffer)
    }

    $menu | Add-Member -MemberType ScriptMethod -Name WriteItems -Value `
    {
        if (-not $this.Content.Items) { return }
        if ($this.Content.Items.Count -eq 1) {
            $currentItemLine = `
                ($script:lineMap | Where-Object { $_.ItemIndex -eq $this.Content.CurrentItem }).Number
            $this.WriteItem(0, 'Green', $currentItemLine)
        } else {
            foreach ($line in $script:lineMap) {
                $fgColor = $this.Square.ForegroundColor
                if ($line.ItemIndex -eq $this.Content.CurrentItem) {
                    $fgColor = $this.ItemHighlightColor
                }
                $this.WriteItem($line.ItemIndex, $fgColor, $line.Number)
            }
        }
    }

    $menu | Add-Member -MemberType ScriptMethod -Name WriteMenu -Value `
    {
        $this.Square.WriteToConsoleBuffer()
        $this.WriteItems()
    }

    $menu | Add-Member -MemberType ScriptMethod -Name UpdateLineMap -Value `
    {
        $script:lineMap = @()
        foreach ($lineNumber in $firstMenuItemLineNumber..$lastMenuItemLineNumber) {
            $script:lineMap += [PSCustomObject]@{
                Number    = $lineNumber
                ItemIndex = $this.Content.CurrentItem
            }
            # We do not want to move to the next item if we already have a full map
            if ($lineNumber -lt $lastMenuItemLineNumber) {
                $this.Content.SelectNextItem()
            }
        }
    }

    $menu | Add-Member -MemberType ScriptMethod -Name NextItem -Value `
    {
        # Write the current item with default colors
        $currentItemLine = ($script:lineMap | Where-Object { $_.ItemIndex -eq $this.Content.CurrentItem }).Number
        $this.WriteItem($this.Content.CurrentItem, $ForegroundColor, $currentItemLine)

        # Select next item and write it with ItemHighlightColor
        $this.Content.SelectNextItem()
        $currentItemLine = ($script:lineMap | Where-Object { $_.ItemIndex -eq $this.Content.CurrentItem }).Number
        # See if we have run out of items on $script:lineMap
        if (-not $currentItemLine) {
            # Rebuild $script:lineMap
            $this.UpdateLineMap()
            # Make the first item on the list the current one
            $this.Content.CurrentItem = ($script:lineMap | Select-Object -First 1).ItemIndex
            # Rewrite the menu using the new map
            $this.WriteMenu()
        } else {
            $this.WriteItem($this.Content.CurrentItem, $this.ItemHighlightColor, $currentItemLine)
        }
    }
 
    $menu | Add-Member -MemberType ScriptMethod -Name PreviousItem -Value `
    {
        # Write the current item with default colors
        $currentItemLine = ($script:lineMap | Where-Object { $_.ItemIndex -eq $this.Content.CurrentItem }).Number
        $this.WriteItem($this.Content.CurrentItem, $ForegroundColor, $currentItemLine)

        # Select previous item and write it with ItemHighlightColor
        $this.Content.SelectPreviousItem()
        $currentItemLine = ($script:lineMap | Where-Object { $_.ItemIndex -eq $this.Content.CurrentItem }).Number
        # See if we have run out of items on $script:lineMap
        if (-not $currentItemLine) {
            # First move back on the list of items to find the correct one to start writing from
            2..($script:lineMap.Count) | Foreach-Object { $this.Content.SelectPreviousItem() }
            # Rebuild $script:lineMap
            $this.UpdateLineMap()
            # Rewrite the menu using the new map
            $this.WriteMenu()
        } else {
            $this.WriteItem($this.Content.CurrentItem, $this.ItemHighlightColor, $currentItemLine)
        }
    }
    
    # Write the next batch of items (if there's too many items to show simultaneously)
    $menu | Add-Member -MemberType ScriptMethod -Name NextPage -Value `
    {
        # Check that there's actually more items on the list than can fit on the menu
        if ($this.Content.Items.Count -le $lastMenuItemLineNumber - $firstMenuItemLineNumber - 1) { return }

        # Get to the last item on $script:linemap using $this.Content.SelectNextItem()
        while ($this.Content.CurrentItem -ne $script:linemap[-1].ItemIndex) {
            $this.Content.SelectNextItem()
        }
        # Do $this.NextItem() to move to next page
        $this.NextItem()
    }

    # Write the previous batch of items (if there's too many items to show simultaneously)
    $menu | Add-Member -MemberType ScriptMethod -Name PreviousPage -Value `
    {
        # Check that there's actually more items on the list than can fit on the menu
        if ($this.Content.Items.Count -le $lastMenuItemLineNumber - $firstMenuItemLineNumber - 1) { return }

        # Get to the first item on $script:linemap using $this.Content.SelectPreviousItem()
        while ($this.Content.CurrentItem -ne $script:linemap[0].ItemIndex) {
            $this.Content.SelectPreviousItem()
        }
        # Do $this.PreviousItem() to move to last page
        $this.PreviousItem()
    }

    # Find next item matching a pattern
    $menu | Add-Member -MemberType ScriptMethod -Name FindNextItem -Value `
    {
        Param(
            [Parameter(Mandatory=$true)][String]$Pattern
        )
        # For example, find the next item from the currently selected one 
        # the name of which starts with X and move to it
        if ($this.Content.FindAndSelectNextItem($Pattern)) {
            # Rebuild $script:lineMap
            $this.UpdateLineMap()
            # Rewrite the menu using the new map
            $this.WriteMenu()
            
            # UpdateLineMap() moved the selected item to the last one on the menu and 
            # wrote it in the highlightcolor. Write it in the unselected foreground color.
            $currentItemLine = `
                ($script:lineMap | Where-Object { $_.ItemIndex -eq $this.Content.CurrentItem }).Number
            $this.WriteItem($this.Content.CurrentItem, $ForegroundColor, $currentItemLine)
            
            # Now change the current item to the one at the top of the menu and 
            # write it in the highlightcolor
            $this.Content.CurrentItem = ($script:lineMap | Select-Object -First 1).ItemIndex
            $currentItemLine = `
                ($script:lineMap | Where-Object { $_.ItemIndex -eq $this.Content.CurrentItem }).Number
            $this.WriteItem($this.Content.CurrentItem, $ItemHighlightColor, $currentItemLine)
        }
    }

    # Find previous item matching a pattern
    $menu | Add-Member -MemberType ScriptMethod -Name FindPreviousItem -Value `
    {
        # For example, find the previous item from the currently selected one 
        # the name of which starts with X and move to it
    }

    # Return the currently selected item
    $menu | Add-Member -MemberType ScriptMethod -Name GetCurrentItem -Value `
    {
        $this.Content.GetCurrentItem()
    }

    # Exit the menu
    $menu | Add-Member -MemberType ScriptMethod -Name Exit -Value `
    {
        # Restore the console buffer from before the menu was written
        $this.Square.RestoreBuffer()
    }

    $menu | Add-Member -MemberType ScriptMethod -Name ReadKey `
    {
        $bail = $false
        while ($bail -eq $false) {
            $hideKeysStrokes = $true
            $key = ([Console]::ReadKey($hideKeysStrokes)).Key
            switch ($key) {
                UpArrow     {
                    $this.PreviousItem()
                }
                DownArrow   {
                    $this.NextItem()
                }
                PageUp     {
                    $this.PreviousPage()
                }
                PageDown   {
                    $this.NextPage()
                }
                Escape {
                    $bail = $true
                }
                Enter {
                    $bail = $true
                    $this.GetCurrentItem()
                }
                Tab {
                    # TODO Change search direction
                }
                Default {
                    $key = $key.ToString()
                    if ($key -match '[a-zA-Z]\d{0,1}' -and $key.length -le 2) {
                        # Numbers get returned with a leading D
                        if ($key -match '^D\d') {
                            $key = $key -replace '^D'
                        }
                        $key = "^$key"
                        $this.FindNextItem($key)
                    }
                }
            }
        }
        $this.Exit()
    }

    $menu.WriteMenu()
    $menu.ReadKey()
}

Export-ModuleMember -Function New-Menu
